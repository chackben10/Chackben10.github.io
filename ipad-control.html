<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>ICAS iPad Control</title>

  <style>
    :root{
      /* Match the left page background (your left site is white) */
      --page-bg: #ffffff;

      /* Divider */
      --divider-w: 14px;
      --leftW: 50vw;

      /* Colors (subtle, clean) */
      --rail: rgba(0,0,0,0.10);
      --rail-border: rgba(0,0,0,0.12);
      --thumb: rgba(0,0,0,0.18);
      --thumb-strong: rgba(0,0,0,0.28);

      --hint-bg: rgba(0,0,0,0.72);
      --hint-text: rgba(255,255,255,0.96);
    }

    *{ box-sizing:border-box; margin:0; padding:0; }
    html, body{ height:100%; width:100%; }

    body{
      background: var(--page-bg);
      overflow: hidden;
      -webkit-overflow-scrolling: touch;
      /* Allow normal touches; divider will manage its own behavior */
      touch-action: manipulation;
    }

    .split{
      height: 100vh;
      width: 100vw;
      display: flex;
      align-items: stretch;
      background: var(--page-bg);
    }

    .pane{
      height: 100%;
      overflow: hidden;
      background: var(--page-bg);
    }

    #leftPane{
      flex: 0 0 var(--leftW);
      min-width: 160px;
      max-width: calc(100vw - 160px - var(--divider-w));
    }

    #rightPane{
      flex: 1 1 auto;
      min-width: 160px;
      background: var(--page-bg);
    }

    iframe{
      width: 100%;
      height: 100%;
      border: 0;
      display: block;
      background: transparent;
    }

    /* Divider (clean + subtle) */
    .divider{
      flex: 0 0 var(--divider-w);
      width: var(--divider-w);
      position: relative;
      background: var(--rail);
      box-shadow: inset 0 0 0 1px var(--rail-border);
      cursor: default;
      -webkit-tap-highlight-color: transparent;
      user-select: none;
      touch-action: none; /* we control gestures on divider only */
    }

    /* A thin center line */
    .divider::before{
      content:"";
      position:absolute;
      top:0; bottom:0;
      left:50%;
      width:2px;
      transform:translateX(-50%);
      background: rgba(0,0,0,0.14);
    }

    /* Thumb handle */
    .thumb{
      position:absolute;
      left:50%;
      top:50%;
      transform:translate(-50%, -50%);
      width: 10px;
      height: 74px;
      border-radius: 999px;
      background: rgba(255,255,255,0.75);
      box-shadow: 0 8px 22px rgba(0,0,0,0.12);
      display:flex;
      align-items:center;
      justify-content:center;
      pointer-events:none;
    }

    .thumb::after{
      content:"";
      width: 3px;
      height: 38px;
      border-radius: 999px;
      background: var(--thumb);
    }

    /* Locked vs armed states */
    .divider.armed{
      background: rgba(0,0,0,0.14);
      box-shadow: inset 0 0 0 1px rgba(0,0,0,0.18);
      cursor: col-resize;
    }
    .divider.armed::before{ background: rgba(0,0,0,0.22); }
    .divider.armed .thumb::after{ background: var(--thumb-strong); }

    /* Little “Hold to resize” hint */
    .hold-hint{
      position: absolute;
      left: 50%;
      top: 16px;
      transform: translateX(-50%);
      background: var(--hint-bg);
      color: var(--hint-text);
      font-size: 12px;
      font-weight: 700;
      padding: 6px 10px;
      border-radius: 999px;
      letter-spacing: 0.2px;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.18s ease, transform 0.18s ease;
      white-space: nowrap;
    }
    .divider.show-hint .hold-hint{
      opacity: 1;
      transform: translateX(-50%) translateY(0);
    }

    /* Optional: when armed, show a small progress ring */
    .ring{
      position:absolute;
      left:50%;
      top:50%;
      transform:translate(-50%,-50%);
      width: 44px;
      height: 44px;
      border-radius: 999px;
      background:
        conic-gradient(rgba(0,0,0,0.35) var(--p, 0deg), rgba(0,0,0,0.0) 0);
      opacity: 0;
      transition: opacity 0.12s ease;
      pointer-events:none;
    }
    .divider.holding .ring{ opacity: 1; }
  </style>
</head>

<body>
  <div class="split" id="splitRoot">
    <div class="pane" id="leftPane">
      <iframe
        src="https://icas-clicker.work"
        title="ICAS Clicker"
        loading="eager"
        referrerpolicy="no-referrer"
        allow="fullscreen"
      ></iframe>
    </div>

    <div class="divider" id="divider" aria-label="Hold to resize split" role="separator" aria-orientation="vertical">
      <div class="hold-hint" id="holdHint">Hold 2s to resize</div>
      <div class="ring" id="ring"></div>
      <div class="thumb" aria-hidden="true"></div>
    </div>

    <div class="pane" id="rightPane">
      <iframe
        src="https://icas-clicker.work/control"
        title="ICAS Control"
        loading="eager"
        referrerpolicy="no-referrer"
        allow="fullscreen"
      ></iframe>
    </div>
  </div>

  <script>
    (function () {
      const divider = document.getElementById("divider");
      const splitRoot = document.getElementById("splitRoot");
      const ring = document.getElementById("ring");

      const LEFT_W_KEY = "icas-ipad-leftW-px";

      const HOLD_MS = 2000;         // must hold for 2s
      const MOVE_CANCEL_PX = 10;    // if finger moves too much before hold completes, cancel

      function clamp(n, lo, hi){ return Math.max(lo, Math.min(hi, n)); }

      function applyLeftWidthPx(px) {
        document.documentElement.style.setProperty("--leftW", px + "px");
      }

      function getSavedLeftWidthPx() {
        const raw = parseInt(localStorage.getItem(LEFT_W_KEY), 10);
        return Number.isFinite(raw) ? raw : null;
      }

      function saveLeftWidthPx(px) {
        localStorage.setItem(LEFT_W_KEY, String(Math.round(px)));
      }

      function initWidth() {
        const saved = getSavedLeftWidthPx();
        if (saved != null) applyLeftWidthPx(saved);
        else applyLeftWidthPx(Math.round(window.innerWidth * 0.5));
      }

      function setFromClientX(clientX) {
        const rect = splitRoot.getBoundingClientRect();
        const dividerW = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--divider-w")) || 14;

        const minLeft = 160;
        const maxLeft = (rect.width - dividerW - 160);

        const px = clamp(clientX - rect.left, minLeft, maxLeft);
        applyLeftWidthPx(px);
        saveLeftWidthPx(px);
      }

      let pointerId = null;
      let startX = 0;
      let startY = 0;
      let holdTimer = null;
      let holdStart = 0;
      let holding = false;  // countdown in progress
      let armed = false;    // hold completed; now resizing allowed
      let rafId = null;

      function resetHoldUI() {
        divider.classList.remove("holding", "armed");
        divider.style.setProperty("--p", "0deg");
        holding = false;
        armed = false;
        if (rafId) cancelAnimationFrame(rafId);
        rafId = null;
      }

      function startProgressRing() {
        holdStart = performance.now();
        divider.classList.add("holding");

        const tick = (t) => {
          const elapsed = t - holdStart;
          const pct = clamp(elapsed / HOLD_MS, 0, 1);
          divider.style.setProperty("--p", (pct * 360) + "deg");
          if (holding && pct < 1) rafId = requestAnimationFrame(tick);
        };

        rafId = requestAnimationFrame(tick);
      }

      function beginHold() {
        holding = true;
        startProgressRing();

        holdTimer = setTimeout(() => {
          // now allow resizing
          holding = false;
          armed = true;
          divider.classList.remove("holding");
          divider.classList.add("armed");
          divider.style.setProperty("--p", "360deg");
        }, HOLD_MS);
      }

      function cancelHold() {
        if (holdTimer) clearTimeout(holdTimer);
        holdTimer = null;
        resetHoldUI();
      }

      divider.addEventListener("pointerdown", (e) => {
        // Start the 2s hold. Do NOT resize yet.
        pointerId = e.pointerId;
        startX = e.clientX;
        startY = e.clientY;
        cancelHold(); // clear any previous state
        divider.classList.add("show-hint");
        beginHold();

        try { divider.setPointerCapture(pointerId); } catch {}
        e.preventDefault();
      });

      divider.addEventListener("pointermove", (e) => {
        if (pointerId === null || e.pointerId !== pointerId) return;

        const dx = Math.abs(e.clientX - startX);
        const dy = Math.abs(e.clientY - startY);

        // If user starts scrolling/moving before it arms, cancel the hold
        if (!armed && (dx > MOVE_CANCEL_PX || dy > MOVE_CANCEL_PX)) {
          cancelHold();
          divider.classList.remove("show-hint");
          pointerId = null;
          try { divider.releasePointerCapture(e.pointerId); } catch {}
          return;
        }

        // Only resize after hold is complete (armed)
        if (armed) {
          setFromClientX(e.clientX);
          e.preventDefault();
        }
      });

      function endPointer(e) {
        if (pointerId === null || e.pointerId !== pointerId) return;

        // If they let go before armed, just cancel (no resize)
        if (!armed) cancelHold();

        divider.classList.remove("show-hint");
        pointerId = null;

        try { divider.releasePointerCapture(e.pointerId); } catch {}
        // Keep armed state only while finger is down; on release, lock again
        resetHoldUI();
        e.preventDefault();
      }

      divider.addEventListener("pointerup", endPointer);
      divider.addEventListener("pointercancel", endPointer);

      // Keep split sane on rotate/resize
      window.addEventListener("resize", () => {
        const rect = splitRoot.getBoundingClientRect();
        const dividerW = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--divider-w")) || 14;

        const minLeft = 160;
        const maxLeft = (rect.width - dividerW - 160);

        const saved = getSavedLeftWidthPx();
        const px = clamp(saved != null ? saved : rect.width * 0.5, minLeft, maxLeft);
        applyLeftWidthPx(px);
        saveLeftWidthPx(px);
      });

      initWidth();
    })();
  </script>
</body>
</html>